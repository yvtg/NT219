<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>ƒê·ªì √°n NT219 - B·∫£o m·∫≠t ƒëa ph∆∞∆°ng ti·ªán</title>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            margin: 2em; 
            background: #f5f5f5;
        }
        #video-container { 
            max-width: 800px; 
            margin: auto; 
            background: white;
            padding: 2em;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        video { 
            width: 100%; 
            background: #000; 
            border-radius: 4px;
        }
        .controls { 
            text-align: center; 
            margin-top: 1em; 
        }
        .controls button { 
            font-size: 1em; 
            padding: 0.5em 1em; 
            margin: 0.5em; 
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .controls button:hover {
            background: #0056b3;
        }
        .controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .instructions {
            margin-top: 2em;
            padding: 1em;
            background: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        pre {
            background: #2d3748;
            color: #e2e8f0;
            padding: 1em;
            border-radius: 4px;
            overflow-x: auto;
        }
        .status {
            margin-top: 1em;
            padding: 0.5em;
            border-radius: 4px;
            text-align: center;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .config {
            margin-top: 1em;
            padding: 1em;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
        }
        .config input {
            width: 300px;
            padding: 0.5em;
            margin: 0.5em;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>

<div id="video-container">
    <h1>üîê Tr√¨nh ph√°t video b·∫£o m·∫≠t</h1>
    
    <div class="config">
        <h3>‚öôÔ∏è C·∫•u h√¨nh Server</h3>
        <label>Server URL:</label>
        <input type="text" id="serverUrl" value="http://127.0.0.1:8000" placeholder="http://127.0.0.1:8000">
        <label>Auth Token (t√πy ch·ªçn):</label>
        <input type="text" id="authToken" placeholder="Bearer token n·∫øu c·∫ßn">
    </div>
    
    <video id="videoPlayer" controls>
        <p>Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ video HTML5.</p>
    </video>
    
    <div class="controls">
        <p><strong>üì• T·∫£i c√°c file x√°c th·ª±c:</strong></p>
        <button onclick="downloadFile('/api/get-public-key', 'public_key.pem')">
            üìÑ T·∫£i Public Key
        </button>
        <button onclick="downloadFile('/api/get-signature', 'video.sig')">
            ‚úçÔ∏è T·∫£i Ch·ªØ k√Ω s·ªë
        </button>
        <button onclick="loadVideo()">
            ‚ñ∂Ô∏è T·∫£i Video
        </button>
    </div>
    
    <div id="status"></div>
    
    <div class="instructions">
        <h3>üìã H∆∞·ªõng d·∫´n x√°c th·ª±c</h3>
        <ol>
            <li>T·∫£i <strong>Public Key</strong> v√† <strong>Ch·ªØ k√Ω s·ªë</strong> b·∫±ng c√°c n√∫t tr√™n</li>
            <li>T·∫£i file video c√≥ watermark t·ª´: <code>/media/video_watermarked.mp4</code></li>
            <li>M·ªü terminal v√† ch·∫°y l·ªánh x√°c th·ª±c:</li>
        </ol>
        <pre><code>openssl dgst -sha256 -verify public_key.pem -signature video.sig video_watermarked.mp4</code></pre>
        <p><strong>‚úÖ K·∫øt qu·∫£ mong ƒë·ª£i:</strong> <code>Verified OK</code></p>
        
        <h4>üîç Gi·∫£i th√≠ch:</h4>
        <ul>
            <li><strong>Public Key:</strong> Kh√≥a c√¥ng khai ƒë·ªÉ x√°c th·ª±c ch·ªØ k√Ω</li>
            <li><strong>Ch·ªØ k√Ω s·ªë:</strong> Ch·ªØ k√Ω ƒë∆∞·ª£c t·∫°o t·ª´ video g·ªëc</li>
            <li><strong>Video watermarked:</strong> Video ƒë√£ ƒë∆∞·ª£c th√™m watermark</li>
        </ul>
    </div>
</div>

<script>
// C·∫•u h√¨nh m·∫∑c ƒë·ªãnh
const DEFAULT_SERVER = 'http://127.0.0.1:8000';

function showStatus(message, type = 'info') {
    const statusDiv = document.getElementById('status');
    statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
    
    // T·ª± ƒë·ªông ·∫©n sau 5 gi√¢y
    setTimeout(() => {
        statusDiv.innerHTML = '';
    }, 5000);
}

function getServerUrl() {
    const serverInput = document.getElementById('serverUrl');
    return serverInput.value.trim() || DEFAULT_SERVER;
}

function getAuthToken() {
    const tokenInput = document.getElementById('authToken');
    return tokenInput.value.trim();
}

function downloadFile(endpoint, filename) {
    const serverUrl = getServerUrl();
    const authToken = getAuthToken();
    const url = serverUrl + endpoint;
    
    // T·∫°o headers
    const headers = {};
    if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
    }
    
    showStatus(`‚è≥ ƒêang t·∫£i ${filename}...`, 'info');
    
    fetch(url, {
        method: 'GET',
        headers: headers
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.blob();
    })
    .then(blob => {
        // T·∫°o link download
        const link = document.createElement('a');
        link.href = window.URL.createObjectURL(blob);
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        
        // Cleanup URL object
        window.URL.revokeObjectURL(link.href);
        
        showStatus(`‚úÖ T·∫£i th√†nh c√¥ng: ${filename}`, 'success');
    })
    .catch(error => {
        console.error('Download failed:', error);
        showStatus(`‚ùå L·ªói t·∫£i file: ${error.message}`, 'error');
    });
}

function loadVideo() {
    const serverUrl = getServerUrl();
    const videoUrl = serverUrl + '/api/playlist.m3u8';
    const video = document.getElementById('videoPlayer');
    
    showStatus('‚è≥ ƒêang t·∫£i video...', 'info');
    
    // Ki·ªÉm tra xem c√≥ ph·∫£i HLS stream kh√¥ng
    if (videoUrl.includes('.m3u8')) {
        // S·ª≠ d·ª•ng HLS.js cho HLS streams
        if (Hls.isSupported()) {
            const hls = new Hls();
            hls.loadSource(videoUrl);
            hls.attachMedia(video);
            hls.on(Hls.Events.MANIFEST_PARSED, function() {
                showStatus('‚úÖ Video HLS ƒë√£ s·∫µn s√†ng', 'success');
            });
            hls.on(Hls.Events.ERROR, function(event, data) {
                showStatus(`‚ùå L·ªói HLS: ${data.details}`, 'error');
            });
        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            // Safari native HLS support
            video.src = videoUrl;
            showStatus('‚úÖ Video ƒë√£ s·∫µn s√†ng (Safari HLS)', 'success');
        } else {
            showStatus('‚ùå Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ HLS', 'error');
        }
    } else {
        // Video th∆∞·ªùng (MP4, etc.)
        video.src = videoUrl;
        video.onloadeddata = function() {
            showStatus('‚úÖ Video ƒë√£ s·∫µn s√†ng', 'success');
        };
        video.onerror = function() {
            showStatus('‚ùå Kh√¥ng th·ªÉ t·∫£i video. Ki·ªÉm tra URL server.', 'error');
        };
    }
}

// T·ª± ƒë·ªông t·∫£i video khi trang load (t√πy ch·ªçn)
window.addEventListener('DOMContentLoaded', function() {
    showStatus('üöÄ Tr√¨nh ph√°t video b·∫£o m·∫≠t ƒë√£ s·∫µn s√†ng', 'info');
});
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netflix - Xem video</title>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script type="module">
        // Import ChaoticCipher v√† g√°n v√†o window ƒë·ªÉ c√≥ th·ªÉ s·ª≠ d·ª•ng ·ªü script kh√°c
        import ChaoticCipher from './chaotic_cipher.js';
        window.ChaoticCipher = ChaoticCipher;
    </script>
    <style>
        :root {
            --netflix-red: #e50914;
            --netflix-dark: #141414;
            --netflix-light-gray: #333;
            --netflix-gray: #8c8c8c;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }
        
        body {
            background-color: var(--netflix-dark);
            color: #fff;
            line-height: 1.5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 20px 4%;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,.7) 10%, rgba(0,0,0,0));
        }

        .logo {
            height: 25px;
        }

        .back-button {
            color: #fff;
            text-decoration: none;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .back-button:hover {
            color: var(--netflix-red);
        }

        .video-container {
            margin-top: 80px;
            padding: 20px 4%;
            flex: 1;
        }

        .videos-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .video-box {
            flex: 1;
            min-width: 300px;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .video-box-title {
            padding: 10px;
            background: var(--netflix-light-gray);
            color: #fff;
            font-size: 14px;
            text-align: center;
        }

        .video-player {
            width: 100%;
            aspect-ratio: 16 / 9;
            background: #000;
        }

        .video-info {
            padding: 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), var(--netflix-dark));
        }

        .video-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
        }

        .video-actions {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .action-button {
            padding: 8px 16px;
            border-radius: 4px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s;
        }

        .play-button {
            background-color: #fff;
            color: #000;
        }

        .play-button:hover {
            background-color: rgba(255, 255, 255, 0.8);
        }

        .like-button, .add-button {
            background-color: rgba(255, 255, 255, 0.2);
            color: #fff;
        }

        .like-button:hover, .add-button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .video-description {
            color: var(--netflix-gray);
            font-size: 14px;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            .video-container {
                padding: 10px 2%;
            }

            .video-title {
                font-size: 20px;
            }

            .video-actions {
                flex-wrap: wrap;
            }

            .action-button {
                font-size: 14px;
                padding: 6px 12px;
            }

            .videos-container {
                flex-direction: column;
            }
            .video-box {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <a href="main.html" class="back-button">
            <span>‚Üê</span> Quay l·∫°i
        </a>
        <svg class="logo" viewBox="0 0 111 30" fill="#e50914">
            <path d="M105.06233,14.2806261..."></path>
        </svg>
    </header>

    <div class="video-container">
        <div class="videos-container">
            <!-- Video ƒë√£ m√£ h√≥a v√† gi·∫£i m√£ -->
            <div class="video-box">
                <div class="video-box-title"></div>
                <video id="encryptedVideoPlayer" class="video-player" controls>
                    <source id="encryptedVideoSource" type="video/mp4">
                    Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ th·∫ª video.
                </video>
            </div>
        </div>

        <div class="video-info">
            <h1 class="video-title" id="video-title">Ti√™u ƒë·ªÅ video</h1>
            <div class="video-actions">
                <button class="action-button play-button" id="playButton">
                    <span>‚ñ∂</span> Ph√°t
                </button>
                <button class="action-button like-button">
                    <span>üëç</span> Th√≠ch
                </button>
                <button class="action-button add-button">
                    <span>+</span> Th√™m v√†o danh s√°ch
                </button>
            </div>
            <p class="video-description" id="video-description">
                M√¥ t·∫£ video s·∫Ω ƒë∆∞·ª£c hi·ªÉn th·ªã ·ªü ƒë√¢y.
            </p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            // ƒê·ª£i ChaoticCipher ƒë∆∞·ª£c import xong
            if (!window.ChaoticCipher) {
                await new Promise(resolve => {
                    const checkCipher = setInterval(() => {
                        if (window.ChaoticCipher) {
                            clearInterval(checkCipher);
                            resolve();
                        }
                    }, 100);
                });
            }

            const urlParams = new URLSearchParams(window.location.search);
            const videoId = urlParams.get('id');
            let chaoticCipher = null;

            if (!videoId) {
                alert('Kh√¥ng t√¨m th·∫•y video');
                window.location.href = 'main.html';
                return;
            }

            try {
                const token = localStorage.getItem('access_token');
                if (!token) throw new Error('Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem video');

                // Kh·ªüi t·∫°o ChaoticCipher t·ª´ token
                console.log('ƒêang kh·ªüi t·∫°o ChaoticCipher t·ª´ token...');
                chaoticCipher = await window.ChaoticCipher.instanceFromToken(token);
                console.log('ƒê√£ kh·ªüi t·∫°o ChaoticCipher th√†nh c√¥ng');

                // L·∫•y th√¥ng tin chi ti·∫øt c·ªßa video t·ª´ backend
                console.log('ƒêang l·∫•y th√¥ng tin video...');
                const videoInfoResponse = await axios.get(`http://localhost:8000/api/videos/${videoId}`, {
                    headers: { Authorization: `Bearer ${token}` }
                });
                console.log('Nh·∫≠n ƒë∆∞·ª£c th√¥ng tin video:', videoInfoResponse.data);

                const { title, description } = videoInfoResponse.data;

                // C·∫≠p nh·∫≠t ti√™u ƒë·ªÅ v√† m√¥ t·∫£ video
                document.title = `${title || 'Video'} - Netflix`;
                const videoTitle = document.getElementById('video-title');
                const videoDescription = document.getElementById('video-description');
                if (videoTitle) videoTitle.textContent = title || 'Ti√™u ƒë·ªÅ video';
                if (videoDescription) videoDescription.textContent = description || '';

                // Thi·∫øt l·∫≠p video player v√† MediaSource
                const encryptedVideoPlayer = document.getElementById('encryptedVideoPlayer');
                let mediaSource;
                let sourceBuffer;
                const chunkSize = 1024 * 1024; // 1MB chunks
                let encryptedCurrentPosition = 0;
                let encryptedTotalSize = 0;
                let isBuffering = false;
                let bufferThreshold = 10 * 1024 * 1024; // 10MB buffer
                let maxBufferSize = 30 * 1024 * 1024; // 30MB max buffer

                async function loadNextEncryptedChunk(retryCount = 0) {
                    const maxRetries = 3;
                    const retryDelay = 1000; // 1 gi√¢y

                    try {
                        console.log(`ƒêang t·∫£i chunk m√£ h√≥a t·ª´ v·ªã tr√≠ ${encryptedCurrentPosition}...`);
                        const response = await axios.get(`http://localhost:8000/api/video/encrypted/${videoId}`, {
                            headers: { 
                                Authorization: `Bearer ${token}`,
                                Range: `bytes=${encryptedCurrentPosition}-${encryptedCurrentPosition + chunkSize - 1}`
                            },
                            responseType: 'arraybuffer',
                            timeout: 10000 // 10 gi√¢y timeout
                        });

                        console.log(`Nh·∫≠n ƒë∆∞·ª£c chunk m√£ h√≥a, status: ${response.status}, size: ${response.data.byteLength} bytes`);

                        if (response.status === 206) {
                            const chunk = new Uint8Array(response.data);
                            
                            // Ki·ªÉm tra xem ƒë√¢y c√≥ ph·∫£i chunk ƒë·∫ßu ti√™n kh√¥ng
                            const isFirstChunk = encryptedCurrentPosition === 0;
                            const startByte = parseInt(response.headers['x-start-byte'] || '0');
                            
                            if (isFirstChunk || startByte > 0) {
                                // Reset tr·∫°ng th√°i cipher t·ª´ token ƒë·ªÉ ƒë·∫£m b·∫£o ƒë·ªìng b·ªô
                                console.log('=== DEBUG CHUNK ===');
                                console.log('Reset cipher state from token...');
                                await chaoticCipher.resetStateFromToken(token);
                                
                                // N·∫øu kh√¥ng ph·∫£i chunk ƒë·∫ßu ti√™n, sinh keystream ƒë·∫øn v·ªã tr√≠ b·∫Øt ƒë·∫ßu
                                if (startByte > 0) {
                                    console.log(`Sinh keystream ƒë·∫øn v·ªã tr√≠ byte ${startByte}...`);
                                    chaoticCipher.generateKeystreamBytes(startByte);
                                }
                                
                                console.log('Cipher state after reset:', chaoticCipher.saveState());
                                
                                // Log d·ªØ li·ªáu tr∆∞·ªõc khi gi·∫£i m√£
                                console.log('D·ªØ li·ªáu tr∆∞·ªõc khi gi·∫£i m√£:');
                                console.log('K√≠ch th∆∞·ªõc chunk:', chunk.length);
                                console.log('16 bytes ƒë·∫ßu ti√™n:', Array.from(chunk.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));
                                
                                // Log keystream
                                const keystream = chaoticCipher.generateKeystreamBytes(16);
                                console.log('Keystream:');
                                console.log('K√≠ch th∆∞·ªõc:', keystream.length);
                                console.log('16 bytes ƒë·∫ßu:', Array.from(keystream.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' '));
                                
                                // Log d·ªØ li·ªáu sau khi gi·∫£i m√£
                                const decryptedTest = new Uint8Array(16);
                                for(let i = 0; i < 16; i++) {
                                    decryptedTest[i] = chunk[i] ^ keystream[i];
                                }
                                console.log('16 bytes ƒë·∫ßu sau khi gi·∫£i m√£:', Array.from(decryptedTest).map(b => b.toString(16).padStart(2, '0')).join(' '));
                                
                                // Ki·ªÉm tra box size v√† type
                                if (decryptedTest.length >= 8) {
                                    // Th·ª≠ c√°c c√°ch ƒë·ªçc box size kh√°c nhau
                                    const boxSizeBE = new DataView(decryptedTest.buffer).getUint32(0, false); // big-endian
                                    const boxSizeLE = new DataView(decryptedTest.buffer).getUint32(0, true);  // little-endian
                                    const boxType = new TextDecoder().decode(decryptedTest.slice(4, 8));
                                    
                                    console.log('Box size (big-endian):', boxSizeBE);
                                    console.log('Box size (little-endian):', boxSizeLE);
                                    console.log('Box type:', boxType);
                                    
                                    // Ki·ªÉm tra c√°c box type h·ª£p l·ªá c·ªßa MP4
                                    const validBoxTypes = ['ftyp', 'moov', 'mdat', 'free', 'skip'];
                                    
                                    // N·∫øu box type kh√¥ng h·ª£p l·ªá, th·ª≠ ƒë·∫£o ng∆∞·ª£c th·ª© t·ª± bytes
                                    if (!validBoxTypes.includes(boxType)) {
                                        console.log('Box type kh√¥ng h·ª£p l·ªá, th·ª≠ ƒë·∫£o ng∆∞·ª£c th·ª© t·ª± bytes...');
                                        
                                        // ƒê·∫£o ng∆∞·ª£c 4 bytes ƒë·∫ßu ti√™n (box size)
                                        const reversedSize = new Uint8Array(4);
                                        for (let i = 0; i < 4; i++) {
                                            reversedSize[i] = decryptedTest[3 - i];
                                        }
                                        
                                        // T·∫°o chunk m·ªõi v·ªõi box size ƒë√£ ƒë·∫£o
                                        const fixedChunk = new Uint8Array(chunk.length);
                                        fixedChunk.set(reversedSize, 0);  // Box size ƒë√£ ƒë·∫£o
                                        fixedChunk.set(chunk.slice(4), 4); // Ph·∫ßn c√≤n l·∫°i gi·ªØ nguy√™n
                                        
                                        // Th·ª≠ gi·∫£i m√£ l·∫°i
                                        const fixedKeystream = chaoticCipher.generateKeystreamBytes(16);
                                        const fixedDecrypted = new Uint8Array(16);
                                        for(let i = 0; i < 16; i++) {
                                            fixedDecrypted[i] = fixedChunk[i] ^ fixedKeystream[i];
                                        }
                                        
                                        const fixedBoxSize = new DataView(fixedDecrypted.buffer).getUint32(0, false);
                                        const fixedBoxType = new TextDecoder().decode(fixedDecrypted.slice(4, 8));
                                        
                                        console.log('Sau khi ƒë·∫£o box size:');
                                        console.log('Box size:', fixedBoxSize);
                                        console.log('Box type:', fixedBoxType);
                                        
                                        if (validBoxTypes.includes(fixedBoxType)) {
                                            console.log('ƒê√£ t√¨m th·∫•y box type h·ª£p l·ªá sau khi ƒë·∫£o box size');
                                            // C·∫≠p nh·∫≠t chunk v·ªõi box size ƒë√£ ƒë·∫£o
                                            chunk.set(fixedChunk);
                                        } else {
                                            throw new Error('Kh√¥ng th·ªÉ t√¨m th·∫•y box type h·ª£p l·ªá sau khi gi·∫£i m√£');
                                        }
                                    }
                                }
                                
                                console.log('=== END DEBUG ===');
                            }
                            
                            // X·ª≠ l√Ω chunk ƒë√£ m√£ h√≥a (bao g·ªìm hash v√† tag)
                            if (chunk.length < 64) { // 32 bytes cho hash + 32 bytes cho tag
                                throw new Error('Chunk qu√° nh·ªè ƒë·ªÉ ch·ª©a d·ªØ li·ªáu h·ª£p l·ªá');
                            }

                            // S·ª≠ d·ª•ng decryptWithHash ƒë·ªÉ gi·∫£i m√£ to√†n b·ªô chunk
                            console.log('ƒêang gi·∫£i m√£ chunk...');
                            const decryptedChunk = await chaoticCipher.decryptWithHash(chunk);
                            console.log('ƒê√£ gi·∫£i m√£ chunk th√†nh c√¥ng, k√≠ch th∆∞·ªõc:', decryptedChunk.length);

                            // Ki·ªÉm tra chunk ƒë·∫ßu ti√™n
                            if (isFirstChunk) {
                                // Debug chi ti·∫øt chunk ƒë·∫ßu ti√™n
                                console.log('Debug chunk ƒë·∫ßu ti√™n:');
                                console.log('K√≠ch th∆∞·ªõc chunk:', decryptedChunk.length);
                                console.log('8 bytes ƒë·∫ßu ti√™n:', Array.from(decryptedChunk.slice(0, 8)).map(b => b.toString(16).padStart(2, '0')).join(' '));
                                
                                // Ki·ªÉm tra header MP4
                                if (decryptedChunk.length < 8) {
                                    throw new Error('Chunk ƒë·∫ßu ti√™n qu√° nh·ªè ƒë·ªÉ ch·ª©a header MP4');
                                }

                                // Ki·ªÉm tra box type MP4
                                const boxSize = new DataView(decryptedChunk.buffer).getUint32(0, false); // false = big-endian
                                const boxType = new TextDecoder().decode(decryptedChunk.slice(4, 8));
                                console.log('Box size:', boxSize);
                                console.log('Box type:', boxType);

                                // Ki·ªÉm tra c√°c box type h·ª£p l·ªá c·ªßa MP4
                                const validBoxTypes = ['ftyp', 'moov', 'mdat', 'free', 'skip'];
                                if (!validBoxTypes.includes(boxType)) {
                                    throw new Error('Video kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng MP4 sau khi gi·∫£i m√£');
                                }
                                console.log('Header MP4 h·ª£p l·ªá:', boxType);

                                // Kh·ªüi t·∫°o MediaSource v√† SourceBuffer cho chunk ƒë·∫ßu ti√™n
                                if (!mediaSource) {
                                    mediaSource = new MediaSource();
                                    encryptedVideoPlayer.src = URL.createObjectURL(mediaSource);
                                    
                                    mediaSource.addEventListener('sourceopen', () => {
                                        try {
                                            sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E, mp4a.40.2"');
                                            sourceBuffer.mode = 'segments';
                                            console.log('MediaSource ƒë√£ s·∫µn s√†ng');
                                        } catch (e) {
                                            console.error('L·ªói kh·ªüi t·∫°o SourceBuffer:', e);
                                            throw e;
                                        }
                                    });
                                }
                            }

                            // ƒê·ª£i MediaSource s·∫µn s√†ng
                            if (mediaSource.readyState === 'closed') {
                                await new Promise(resolve => {
                                    mediaSource.addEventListener('sourceopen', resolve, { once: true });
                                });
                            }

                            // ƒê·ª£i SourceBuffer s·∫µn s√†ng
                            if (!sourceBuffer || sourceBuffer.updating) {
                                await new Promise(resolve => {
                                    const updateEndHandler = () => {
                                        sourceBuffer.removeEventListener('updateend', updateEndHandler);
                                        resolve();
                                    };
                                    sourceBuffer.addEventListener('updateend', updateEndHandler);
                                });
                            }

                            // Th√™m chunk v√†o SourceBuffer
                            try {
                                sourceBuffer.appendBuffer(decryptedChunk);
                                encryptedCurrentPosition += chunk.length;
                                encryptedTotalSize += chunk.length;
                            } catch (e) {
                                console.error('L·ªói khi th√™m chunk v√†o SourceBuffer:', e);
                                throw e;
                            }

                            // N·∫øu ƒë√£ t·∫£i xong, ƒë√≥ng MediaSource
                            if (response.headers['content-range']) {
                                const match = response.headers['content-range'].match(/bytes \d+-\d+\/(\d+)/);
                                if (match && parseInt(match[1]) <= encryptedCurrentPosition) {
                                    console.log('ƒê√£ t·∫£i xong video');
                                    mediaSource.endOfStream();
                                }
                            }
                        } else {
                            throw new Error(`L·ªói HTTP: ${response.status}`);
                        }
                    } catch (error) {
                        console.error(`L·ªói khi t·∫£i chunk (l·∫ßn th·ª≠ ${retryCount + 1}/${maxRetries}):`, error);
                        
                        if (retryCount < maxRetries) {
                            console.log(`ƒê·ª£i ${retryDelay}ms tr∆∞·ªõc khi th·ª≠ l·∫°i...`);
                            await new Promise(resolve => setTimeout(resolve, retryDelay));
                            return loadNextEncryptedChunk(retryCount + 1);
                        }

                        // N·∫øu ƒë√£ h·∫øt s·ªë l·∫ßn th·ª≠ l·∫°i
                        if (error.response) {
                            // L·ªói t·ª´ server
                            if (error.response.status === 401) {
                                alert('Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.');
                                window.location.href = 'login.html';
                            } else if (error.response.status === 404) {
                                alert('Kh√¥ng t√¨m th·∫•y video ho·∫∑c video ƒë√£ b·ªã x√≥a.');
                                window.location.href = 'main.html';
                            } else {
                                alert(`L·ªói server: ${error.response.status} - ${error.response.statusText}`);
                            }
                        } else if (error.request) {
                            // Kh√¥ng nh·∫≠n ƒë∆∞·ª£c response
                            alert('Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn server. Vui l√≤ng ki·ªÉm tra k·∫øt n·ªëi m·∫°ng.');
                        } else {
                            // L·ªói kh√°c
                            alert(`L·ªói: ${error.message}`);
                        }
                        throw error;
                    }
                }

                // B·∫Øt ƒë·∫ßu t·∫£i chunk m√£ h√≥a ƒë·∫ßu ti√™n
                await loadNextEncryptedChunk();

                // X·ª≠ l√Ω s·ª± ki·ªán play cho video m√£ h√≥a
                encryptedVideoPlayer.addEventListener('play', () => {
                    if (encryptedCurrentPosition < encryptedVideoPlayer.duration * 1024 * 1024) {
                        loadNextEncryptedChunk();
                    }
                });

                // Th√™m event listener ƒë·ªÉ debug l·ªói video m√£ h√≥a
                encryptedVideoPlayer.addEventListener('error', (e) => {
                    console.error('L·ªói video player m√£ h√≥a:', encryptedVideoPlayer.error);
                    console.error('Error code:', encryptedVideoPlayer.error.code);
                    console.error('Error message:', encryptedVideoPlayer.error.message);
                    console.log('T·ªïng k√≠ch th∆∞·ªõc m√£ h√≥a:', encryptedTotalSize);
                });

                // NgƒÉn ch·∫∑n t·∫£i xu·ªëng video m√£ h√≥a
                encryptedVideoPlayer.addEventListener('contextmenu', (e) => e.preventDefault());

                // D·ªçn d·∫πp khi r·ªùi trang
                window.addEventListener('beforeunload', () => {
                    URL.revokeObjectURL(encryptedVideoPlayer.src);
                });

                const playButton = document.getElementById('playButton');
                if (playButton) {
                    playButton.addEventListener('click', () => encryptedVideoPlayer.play());
                }

                // H√†m ki·ªÉm tra v√† qu·∫£n l√Ω buffer
                async function manageBuffer() {
                    if (isBuffering) return;
                    
                    const buffered = sourceBuffer.buffered;
                    if (buffered.length === 0) return;
                    
                    const currentTime = encryptedVideoPlayer.currentTime;
                    const bufferedEnd = buffered.end(buffered.length - 1);
                    const bufferedStart = buffered.start(0);
                    
                    // N·∫øu buffer qu√° l·ªõn, x√≥a ph·∫ßn ƒë·∫ßu
                    if (bufferedEnd - bufferedStart > maxBufferSize) {
                        const removeEnd = bufferedStart + (bufferedEnd - bufferedStart - maxBufferSize);
                        if (removeEnd > bufferedStart) {
                            try {
                                await new Promise((resolve, reject) => {
                                    if (sourceBuffer.updating) {
                                        sourceBuffer.addEventListener('updateend', () => {
                                            try {
                                                sourceBuffer.remove(bufferedStart, removeEnd);
                                                resolve();
                                            } catch (e) {
                                                reject(e);
                                            }
                                        }, { once: true });
                                    } else {
                                        try {
                                            sourceBuffer.remove(bufferedStart, removeEnd);
                                            resolve();
                                        } catch (e) {
                                            reject(e);
                                        }
                                    }
                                });
                            } catch (e) {
                                console.error('L·ªói khi x√≥a buffer:', e);
                            }
                        }
                    }
                    
                    // N·∫øu buffer s·∫Øp h·∫øt, t·∫£i th√™m
                    if (bufferedEnd - currentTime < bufferThreshold / 2) {
                        isBuffering = true;
                        try {
                            await loadNextEncryptedChunk();
                        } finally {
                            isBuffering = false;
                        }
                    }
                }

                // Th√™m event listener cho video player
                encryptedVideoPlayer.addEventListener('timeupdate', () => {
                    if (!isBuffering) {
                        manageBuffer();
                    }
                });

                encryptedVideoPlayer.addEventListener('waiting', () => {
                    console.log('Video ƒëang buffer...');
                    if (!isBuffering) {
                        manageBuffer();
                    }
                });

                encryptedVideoPlayer.addEventListener('playing', () => {
                    console.log('Video ƒëang ph√°t');
                    if (!isBuffering) {
                        manageBuffer();
                    }
                });

            } catch (error) {
                console.error('L·ªói khi t·∫£i video:', error);
                alert(error.message || 'Kh√¥ng th·ªÉ ph√°t video');
                window.location.href = 'main.html';
            }
        });

        // Th√™m cleanup khi ƒë√≥ng video
        function cleanup() {
            if (mediaSource && mediaSource.readyState === 'open') {
                try {
                    if (sourceBuffer && !sourceBuffer.updating) {
                        sourceBuffer.abort();
                    }
                    mediaSource.endOfStream();
                } catch (e) {
                    console.error('L·ªói khi cleanup MediaSource:', e);
                }
            }
            
            if (encryptedVideoPlayer.src) {
                URL.revokeObjectURL(encryptedVideoPlayer.src);
                encryptedVideoPlayer.src = '';
            }
            
            mediaSource = null;
            sourceBuffer = null;
            encryptedCurrentPosition = 0;
            encryptedTotalSize = 0;
            isBuffering = false;
        }

        // Th√™m event listener cho cleanup
        window.addEventListener('beforeunload', cleanup);
        encryptedVideoPlayer.addEventListener('ended', cleanup);

        // Th√™m n√∫t ƒë√≥ng video
        const closeButton = document.createElement('button');
        closeButton.className = 'action-button';
        closeButton.innerHTML = '<span>‚úï</span> ƒê√≥ng video';
        closeButton.onclick = () => {
            cleanup();
            window.location.href = 'main.html';
        };
        document.querySelector('.video-actions').appendChild(closeButton);
    </script>

</body>
</html>
